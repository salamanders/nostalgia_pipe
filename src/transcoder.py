import ffmpeg
import subprocess
from pathlib import Path
from typing import List, Tuple, Dict, Any, Optional

class Transcoder:
    def get_audio_settings(self, input_path: Path) -> Dict[str, Any]:
        try:
            probe = ffmpeg.probe(str(input_path))
            audio_stream = next((stream for stream in probe['streams'] if stream['codec_type'] == 'audio'), None)

            if audio_stream and audio_stream['codec_name'] == 'ac3':
                return {'acodec': 'copy'}
            else:
                return {'acodec': 'aac', 'audio_bitrate': '256k'}
        except Exception as e:
            print(f"Error probing audio for {input_path}: {e}")
            return {'acodec': 'aac', 'audio_bitrate': '256k'}

    def create_proxy(self, input_path: Path, output_path: Path) -> bool:
        """
        Creates a highly compressed proxy video for AI analysis.
        Resolution: 360p
        FPS: 5
        Audio: Mono, 32k AAC
        """
        try:
            (
                ffmpeg
                .input(str(input_path))
                .output(
                    str(output_path),
                    vf='scale=-1:360',
                    r=5,
                    vcodec='libx264',
                    crf=32,
                    preset='veryfast',
                    acodec='aac',
                    audio_bitrate='32k',
                    ac=1
                )
                .overwrite_output()
                .run(quiet=True)
            )
            return True
        except Exception as e:
            print(f"Error creating proxy for {input_path}: {e}")
            return False

    def transcode_segment(self, input_path: Path, output_path: Path, start: float, end: float, metadata: Optional[Dict[str, str]] = None) -> bool:
        audio_settings = self.get_audio_settings(input_path)

        # Duration
        duration = end - start

        # Base output arguments
        output_kwargs = {
            'vcodec': 'libx265',
            'crf': 18,
            'preset': 'slower',
            'vf': 'bwdif=mode=1,format=yuv420p10le',
            'pix_fmt': 'yuv420p10le',
            'movflags': '+faststart',
            **audio_settings
        }

        try:
            stream = ffmpeg.input(str(input_path), ss=start, t=duration)
            output_node = stream.output(str(output_path), **output_kwargs)

            # Compile command to inject metadata args manually (to handle multiple -metadata flags)
            cmd_args = ffmpeg.compile(output_node, overwrite_output=True)

            # Identify where to insert metadata (before the output filename)
            # The output filename is usually the last argument in cmd_args generated by ffmpeg-python
            output_file_str = str(output_path)

            # We construct metadata args
            metadata_args = []
            if metadata:
                if 'title' in metadata:
                    metadata_args.extend(['-metadata', f"title={metadata['title']}"])
                if 'description' in metadata:
                    metadata_args.extend(['-metadata', f"comment={metadata['description']}"]) # comment is often used for description
                    metadata_args.extend(['-metadata', f"description={metadata['description']}"])
                if 'year' in metadata:
                    metadata_args.extend(['-metadata', f"date={metadata['year']}"])
                    metadata_args.extend(['-metadata', f"year={metadata['year']}"])
                if 'location' in metadata:
                    metadata_args.extend(['-metadata', f"location={metadata['location']}"])

            # Insert metadata args before the output filename
            # Note: cmd_args looks like ['ffmpeg', '-i', ..., 'output.mp4']
            if output_file_str in cmd_args:
                idx = cmd_args.index(output_file_str)
                # Insert before filename
                cmd_args[idx:idx] = metadata_args
            else:
                # Fallback if filename match fails (unlikely)
                cmd_args.extend(metadata_args)

            # Execute
            subprocess.run(cmd_args, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
            return True

        except subprocess.CalledProcessError as e:
            print(f"Error transcoding segment {input_path} ({start}-{end}): {e.stderr.decode('utf8') if e.stderr else str(e)}")
            return False
        except Exception as e:
            print(f"Error transcoding segment {input_path}: {e}")
            return False
